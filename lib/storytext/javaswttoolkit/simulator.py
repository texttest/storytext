
import storytext.guishared, util, logging, os, time
from storytext.definitions import UseCaseScriptError
from storytext import applicationEvent, applicationEventDelay
from difflib import SequenceMatcher
from org.eclipse import swt
import org.eclipse.swtbot.swt.finder as swtbot
from org.hamcrest.core import IsAnything
from java.lang import IllegalStateException, IndexOutOfBoundsException, RuntimeException, NullPointerException, NoSuchFieldException
from java.text import ParseException
from java.util import ArrayList
from threading import Lock

applicationEventType = 1234 # anything really, just don't conflict with the real SWT events


def runOnUIThread(method, *args):
    class PythonResult(swtbot.results.Result):
        def run(self):
            return method(*args)

    try:
        return swtbot.finders.UIThreadRunnable.syncExec(PythonResult())
    except NullPointerException, e:
        # Temporary code to try to find intermittent Windows error
        print "Caught intermittent Windows NullPointerException!"
        e.printStackTrace()
        raise

class WidgetAdapter(storytext.guishared.WidgetAdapter):
    # All the standard message box texts
    dialogTexts = [ "OK", "Cancel", "Yes", "No", "Abort", "Retry", "Ignore" ]
    menuContexts = {}
    def getChildWidgets(self):
        return [] # don't use this...
        
    def getWidgetTitle(self):
        return ""
        
    def getLabel(self):
        if isinstance(self.widget, (swtbot.widgets.SWTBotText, swtbot.widgets.SWTBotCombo, swtbot.widgets.SWTBotSpinner)) or \
               not hasattr(self.widget.widget, "getText"):
            return self.getFromUIThread(util.getTextLabel, self.widget.widget)
        try:
            text = self.widget.getText()
        except:
            return ""
        text = text.replace("&", "").split("\t")[0]
        if text in self.dialogTexts:
            dialogTitle = self.getDialogTitle()
            if dialogTitle:
                return text + ",Dialog=" + dialogTitle
        return text

    def getDialogTitle(self):
        return self.widget.widget.getShell().getText() if isinstance(self.widget.widget, swt.widgets.Control) else ""

    def getType(self):
        # SWT name, not the SWTBot name
        return self.widget.widget.__class__.__name__
        
    def isAutoGenerated(self, name):
        return len(name) == 0

    def getTooltip(self):
        try:
            return self.widget.getToolTipText()
        except:
            return ""

    def getName(self):
        return self.widget.getId() or ""

    def getNameForAppEvent(self):
        return self.getName() or self.getType().lower()

    def getFromUIThread(self, method, *args):
        try:
            return runOnUIThread(method, *args)
        except:
            return ""
    
    def getContextAncestor(self):
        return runOnUIThread(self.widget.widget.getParent)

    def getContextName(self):
        parent = self.getContextAncestor()
        return self.getContextNameFromAncestor(parent)
    
    def getMenuContextNameFromAncestor(self, parent):
        def getParentText():
            item = parent.getParentItem()
            return item.getText() if item else "Popup Menu"
        parentText = runOnUIThread(getParentText)
        currText = self.getLabel()
        if currText in self.menuContexts and parentText != self.menuContexts.get(currText):
            return parentText
        else:
            self.menuContexts[currText] = parentText
            return ""
    
    def getContextNameFromAncestor(self, parent):
        if isinstance(parent, swt.widgets.Menu):
            return self.getMenuContextNameFromAncestor(parent)
        elif isinstance(parent, swt.widgets.Table):
            return "TableCell"
        elif isinstance(parent, swt.widgets.Tree):
            return "TreeCell"
        else:
            return ""
        

storytext.guishared.WidgetAdapter.adapterClass = WidgetAdapter    
        
class SignalEvent(storytext.guishared.GuiEvent):
    def __init__(self, name, widget, argumentParseData, *args):
        self.generationModifiers = argumentParseData.split(",") if argumentParseData else []
        storytext.guishared.GuiEvent.__init__(self, name, widget, *args)
        
    def connectRecord(self, method):
        class RecordListener(swt.widgets.Listener):
            def handleEvent(listenerSelf, e): #@NoSelf
                storytext.guishared.catchAll(method, e, self)

        eventType = self.getRecordEventType()
        try:
            runOnUIThread(self.addListeners, eventType, RecordListener())
        except: # Get 'widget is disposed' sometimes, don't know why...
            pass
        
    @classmethod
    def getRecordEventType(cls):
        return getattr(swt.SWT, cls.getAssociatedSignal(None))
        
    def addListeners(self, *args):
        # Three indirections: WidgetAdapter -> SWTBotMenu -> MenuItem
        return self.widget.widget.widget.addListener(*args)

    def generate(self, *args):
        try:
            self._generate(*args)
        except (IllegalStateException, IndexOutOfBoundsException), _:
            pass # get these for actions that close the UI. But only after the action is done :)

    def shouldRecord(self, event, *args):
        return DisplayFilter.instance.getEventFromUser(event, self.isTriggeringEvent)
    
    def isTriggeringEvent(self, *args):
        return False

    def delayLevel(self, event, *args):
        # If there are events for other shells, implies we should delay as we're in a dialog
        return DisplayFilter.instance.otherEventCount(event, self.isTriggeringEvent)

    def widgetDisposed(self):
        return runOnUIThread(self.widget.widget.widget.isDisposed)

    def widgetVisible(self):
        return self.widget.isVisible()
        
    def widgetSensitive(self):
        return self.widget.isEnabled()
        
    def describeWidget(self):
        return "of type " + self.widget.getType()
    
    @classmethod
    def getSignalsToFilter(cls):
        return [ cls.getRecordEventType() ]


class StateChangeEvent(SignalEvent):
    def outputForScript(self, *args):
        return ' '.join([self.name, self.getStateText(*args) ])

    def isStateChange(self, *args):
        return True


class SelectEvent(SignalEvent):    
    def _generate(self, *args):
        self.widget.click()

    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Selection"


class LinkSelectEvent(SelectEvent):
    def _generate(self, *args):
        # There is self.widget.click(), but it is very low level, seizes the mouse pointer,
        # and fails utterly under KDE. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=337548
        text = self.widget.getText()
        startPos = text.find(">") + 1
        endPos = text.rfind("<")
        hyperlinkText = text[startPos:endPos]
        self.widget.click(hyperlinkText)
            
        
class RadioSelectEvent(SelectEvent):
    def shouldRecord(self, event, *args):
        return SignalEvent.shouldRecord(self, event, *args) and event.widget.getSelection()

    def getSelectedButton(self):
        method = swtbot.widgets.SWTBotRadio.getDeclaredMethod("otherSelectedButton", None)
        method.setAccessible(True)
        return method.invoke(self.widget.widget, None)
        
    def _generate(self, *args):
        if self.widget.isInstanceOf(swtbot.widgets.SWTBotRadio):
            # Workaround for bug in SWTBot which doesn't handle Eclipse radio buttons properly
            # See https://bugs.eclipse.org/bugs/show_bug.cgi?id=344484 for details
            selectedButton = self.getSelectedButton()
            runOnUIThread(selectedButton.widget.setSelection, False)
        SelectEvent._generate(self)
        
# just so we can distinguish later on...
class SWTBotRadioMenu(swtbot.widgets.SWTBotMenu):
    def click(self):
        # This case also isn't handled correctly by SWTBot!
        # See https://bugs.eclipse.org/bugs/show_bug.cgi?id=397649    
        selectedMenuItem = runOnUIThread(self.getSelectedMenuItem)
        if selectedMenuItem:
            swtbot.widgets.SWTBotMenu(selectedMenuItem).click() # Should have same effect, i.e. disable it
        swtbot.widgets.SWTBotMenu.click(self)

    def getSelectedMenuItem(self):
        menu = self.widget.getParent()
        for item in menu.getItems():
            if item.getStyle() & swt.SWT.RADIO and item.getSelection():
                return item
            
    
class TabEvent(SelectEvent):
    def findTabWithText(self, text):
        for item in self.widget.widget.widget.getItems():
            if item.getText() == text:
                return item
        
    def parseArguments(self, text):
        # Seems we can only get tab item text in the UI thread (?)
        item = runOnUIThread(self.findTabWithText, text)
        if item:
            return item
        else:
            raise UseCaseScriptError, "Could not find tab labelled '" + text + "' in TabFolder."
    
    def getItemText(self, item):
        return item.getText()
    
    def outputForScript(self, event, *args):
        # Text may have changed since the application listeners have been applied
        return ' '.join([self.name, self.getItemText(event.item)])

    
class TabSelectEvent(TabEvent):
    swtbotItemClass = swtbot.widgets.SWTBotTabItem
    def _generate(self, tab):
        self.swtbotItemClass(tab).activate()
            

class CTabSelectEvent(TabSelectEvent):
    swtbotItemClass = swtbot.widgets.SWTBotCTabItem
    def isStateChange(self):
        return True

    def implies(self, *args):
        # State change because it can be implied by CTabCloseEvents
        # But don't amalgamate them together, allow several tabs to be selected in sequence
        return False


class CTabCloseEvent(TabEvent):
    def connectRecord(self, method):
        class RecordListener(swt.custom.CTabFolder2Adapter):
            def close(listenerSelf, e): #@NoSelf
                storytext.guishared.catchAll(method, e, self)

        runOnUIThread(self.widget.widget.widget.addCTabFolder2Listener, RecordListener())
        
    @classmethod
    def getRecordEventType(cls):
        return getattr(swt.SWT, cls.getAssociatedSignal(None))
        
    def addListeners(self, *args):
        # Three indirections: WidgetAdapter -> SWTBotMenu -> MenuItem
        return self.widget.widget.widget.addListener(*args)
    
    def _generate(self, tab):
        swtbot.widgets.SWTBotCTabItem(tab).close()

    def shouldRecord(self, *args):
        return DisplayFilter.instance.hasEventOfType([ swt.SWT.MouseUp ], self.widget.widget.widget)

    def isTriggeringEvent(self, e):
        return e.type == swt.SWT.MouseUp

    @classmethod
    def getSignalsToFilter(cls):
        return [ swt.SWT.MouseUp, swt.SWT.Dispose ]

    @classmethod
    def getAssociatedSignal(cls, widget):
        return "CloseTab"


class ShellCloseEvent(SignalEvent):    
    def _generate(self, *args):
        # SWTBotShell.close appears to close things twice, just use the ordinary one for now...
        class CloseRunnable(swtbot.results.VoidResult):
            def run(resultSelf): #@NoSelf
                self.widget.widget.widget.close()
                
        swtbot.finders.UIThreadRunnable.asyncExec(CloseRunnable())
        
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Close"
    

class ResizeEvent(StateChangeEvent):
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Resize"

    def _generate(self, argumentString):
        words = argumentString.split()
        width = int(words[1])
        height = int(words[-1])
        runOnUIThread(self.widget.widget.widget.setSize, width, height)

    def dimensionText(self, dimension):
        return str((dimension / 10) * 10)
    
    def getSize(self):
        size = self.widget.widget.widget.getSize()
        return size.x, size.y 
        
    def getStateText(self, *args):
        width, height = self.getSize()
        return "width " + self.dimensionText(width) + " and height " + self.dimensionText(height)

class FreeTextEvent(SignalEvent):
    def connectRecord(self, method):
        pass # Intended for events in filechoosers etc, which we cannot record anyway
    
    @classmethod
    def getSignalsToFilter(cls):
        return []
    
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "TypeText"
    
    def shouldRecord(self, *args):
        return False
    
    def generate(self, argumentString):
        method = self.widget.widget.getClass().getSuperclass().getSuperclass().getDeclaredMethod("keyboard", None)
        method.setAccessible(True)
        keyboard = method.invoke(self.widget.widget, None)
        keyboard.typeText(argumentString + "\n", swtbot.utils.SWTBotPreferences.TYPE_INTERVAL)


class SpinnerSelectEvent(StateChangeEvent):
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Selection"
    
    def getStateText(self, *args):
        return self.widget.getText()
    
    def _generate(self, argumentString):
        self.widget.setSelection(int(argumentString))

    
class TextEvent(StateChangeEvent):
    physicalEventWidget = None
    def __init__(self, *args):
        StateChangeEvent.__init__(self, *args)
        self.stateText = None
    
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Modify"
    
    def connectRecord(self, method):
        StateChangeEvent.connectRecord(self, method)
        if self.isTyped():
            class PhysicalEventListener(swt.widgets.Listener):
                def handleEvent(listenerSelf, e): #@NoSelf
                    TextEvent.physicalEventWidget = e.widget

            runOnUIThread(self.addListeners, swt.SWT.KeyDown, PhysicalEventListener())
            runOnUIThread(self.addListeners, swt.SWT.MouseDown, PhysicalEventListener())
        
    def selectAll(self):
        self.widget.selectAll()
        
    def isTriggeringEvent(self, e):
        # Don't include the Enter presses from TextActivateEvent below...
        return e.type == swt.SWT.KeyDown and e.character != swt.SWT.CR

    def isTyped(self):
        return "typed" in self.generationModifiers

    def _generate(self, argumentString):
        self.widget.setFocus()
        if self.isTyped() and argumentString:
            self.selectAll()
            self.widget.typeText(argumentString)
        else:
            self.widget.setText(argumentString)

    def getStateText(self, *args):
        return self.widget.getText()
    
    def shouldRecord(self, event, *args):
        if not self.isEditable():
            return False
        newStateText = self.getStateText()
        if self.stateText is not None and self.stateText == newStateText:
            return False
        
        if newStateText and self.isTyped() and self.physicalEventWidget is not self.widget.widget.widget:
            return False
        
        self.stateText = newStateText
        return not self.widget.widget.widget in CComboSelectEvent.internalWidgets and StateChangeEvent.shouldRecord(self, event, *args)
        
    def isEditable(self):
        return not (self.widget.widget.widget.getStyle() & swt.SWT.READ_ONLY) 
    
    def implies(self, stateChangeOutput, *args):
        if self.isTyped():
            currOutput = self.outputForScript(*args)
            return StateChangeEvent.implies(self, stateChangeOutput, *args) and \
               self.hasGainedOrLostCharacters(currOutput, stateChangeOutput)
        else:
            return StateChangeEvent.implies(self, stateChangeOutput, *args)
            
    @classmethod
    def hasGainedOrLostCharacters(cls, text1, text2):
        matcher = SequenceMatcher(None, text1, text2)
        blocks = matcher.get_matching_blocks()
        totalMatchLength = sum((block[2] for block in blocks))
        return totalMatchLength == min(len(text1), len(text2)) and cls.mismatchingSectionCount(blocks) <= 1
    
    @staticmethod
    def mismatchingSectionCount(blocks):
        # We want to make sure text has only been inserted or deleted in a block, as a user would do
        startMismatch = blocks[0][0] > 0 or blocks[0][1] > 0
        middleMismatches = max(len(blocks) - 2, 0)
        endMismatch = blocks[-2][0] + blocks[-2][2] != blocks[-1][0] or \
                      blocks[-2][1] + blocks[-2][2] != blocks[-1][1]
        return int(startMismatch) + middleMismatches + int(endMismatch)
        
            
class TextActivateEvent(SignalEvent):
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Activate"
    
    @classmethod
    def getRecordEventType(cls):
        return swt.SWT.Traverse
    
    def isTraverseReturn(self, event):
        return event.type == swt.SWT.Traverse and event.detail == swt.SWT.TRAVERSE_RETURN

    def isTriggeringEvent(self, event):
        return event.widget in CComboChangeEvent.internalWidgets and self.isTraverseReturn(event)
    
    def shouldRecord(self, event, *args):
        return not self.widget.widget.widget in CComboChangeEvent.internalWidgets and self.isTraverseReturn(event) and \
            (not self.widget.isInstanceOf(FakeSWTBotCCombo) or \
             DisplayFilter.instance.hasEventOfType([ swt.SWT.Traverse ], getPrivateField(self.widget.widget.widget, "text")))
    
    def _generate(self, argumentString):
        self.widget.setFocus()
        self.widget.typeText("\n")

class ComboTextEvent(TextEvent):
    def _generate(self, argumentString):
        try:
            if runOnUIThread(TextEvent.isEditable, self):
                TextEvent._generate(self, argumentString)
            else:
                self.widget.setSelection(argumentString)
        except RuntimeException, e:
            raise UseCaseScriptError, e.getMessage()

    def selectAll(self):
        # Strangely, there is no selectAll method...
        selectionPoint = swt.graphics.Point(0, len(self.widget.getText()))
        runOnUIThread(self.widget.widget.widget.setSelection, selectionPoint)

    def isEditable(self):
        # Better would be to listen for selection in the readonly case. As it is, can't do what we do on TextEvent
        return True
    
    def isTriggeringEvent(self, e):
        # Combo editing sometimes generates two modify events, one "inside" the other
        # Without this we risk the inner one being rejected because the outer one hasn't run,
        # and the outer being rejected because the inner one has updated the text already
        return e.type == swt.SWT.Modify and e.widget is self.widget.widget.widget
    
def getPrivateField(obj, fieldName):
    cls = obj.getClass()
    while cls is not None:
        try:
            declaredField = cls.getDeclaredField(fieldName)
            declaredField.setAccessible(True)
            return declaredField.get(obj)
        except NoSuchFieldException:
            cls = cls.getSuperclass()

class CComboSelectEvent(StateChangeEvent):
    internalWidgets = []
    def __init__(self, *args):
        StateChangeEvent.__init__(self, *args)
        self.stateText = None
        self.addWidgets()

    def addWidgets(self):
        list_ =  getPrivateField(self.widget.widget.widget, "list")
        text_ =  getPrivateField(self.widget.widget.widget, "text")
        self.internalWidgets.append(list_)
        self.internalWidgets.append(text_)
    
    def getStateText(self, *args):
        return self.widget.getText()
    
    def _generate(self, argumentString):
        try:
            self.widget.setSelection(argumentString)
        except RuntimeException, e:
            raise UseCaseScriptError, e.getMessage()
        
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Selection"

    def implies(self, stateChangeOutput, stateChangeEvent, *args):
        currOutput = self.outputForScript(*args)
        _, currSelection = currOutput.split(self.name, 1)
        _, oldSelection = stateChangeOutput.split(stateChangeEvent.name, 1)
        return (isinstance(stateChangeEvent, CComboChangeEvent) and currSelection == oldSelection) or StateChangeEvent.implies(self, stateChangeOutput, *args)

    def shouldRecord(self, event, *args):
        newStateText = self.getStateText()
        if self.stateText is not None and self.stateText == newStateText:
            return False
        self.stateText = newStateText
        return StateChangeEvent.shouldRecord(self, event, *args)
    
    def isTriggeringEvent(self, e):
        return e.widget in self.internalWidgets or StateChangeEvent.isTriggeringEvent(self, e)


class CComboChangeEvent(CComboSelectEvent):
    def _generate(self, argumentString):
        try:
            self.widget.setFocus()
            self.widget.setText(argumentString)
        except RuntimeException, e:
            raise UseCaseScriptError, e.getMessage()

    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Modify"
    
    def implies(self, stateChangeOutput, stateChangeEvent, *args):
        return StateChangeEvent.implies(self, stateChangeOutput, stateChangeEvent, *args)


class StoryTextSwtBotTable(swtbot.widgets.SWTBotTable):    
    def select(self, indices):
        # When clicking in a cell, SWTBot likes to select the entire row first, generating mouse events and all
        # This can cause trouble, e.g. the cells can translate it into clicking the first column
        runOnUIThread(self.widget.deselectAll)
        for i in indices:
            runOnUIThread(self.widget.select, i)


class TableSelectEvent(StateChangeEvent):
    def __init__(self, *args):
        StateChangeEvent.__init__(self, *args)
        TableIndexer.getIndexer(self.widget.widget.widget)

    @classmethod
    def getAssociatedSignal(cls, widget):
        return "MouseDown"
    
    @classmethod
    def getAssociatedSignatures(cls, widget):
        return [ "CellSelection" ]
    
    def parseArguments(self, argumentString):
        indexer = TableIndexer.getIndexer(self.widget.widget.widget)
        row, col = indexer.getViewCellIndices(argumentString)
        return row, col
            
    def _generate(self, cell):
        self.widget.click(*cell)
        
    def getStateText(self, event, *args):
        row, col = self.findCell(event)
        indexer = TableIndexer.getIndexer(self.widget.widget.widget)
        return indexer.getCellDescription(row, col)
    
    def clickCount(self):
        return 1
    
    def shouldRecord(self, event, *args):
        if event.count != self.clickCount():
            return False
        row, _ = self.findCell(event)
        return row is not None and StateChangeEvent.shouldRecord(self, event, *args)
    
    def findCell(self, event):
        pt = swt.graphics.Point(event.x, event.y)
        table = event.widget
        firstRow = table.getTopIndex()
        for rowIndex in range(firstRow, firstRow + table.getItemCount()):
            item = table.getItem(rowIndex)
            for col in range(table.getColumnCount()):
                rect = item.getBounds(col)
                if rect.contains(pt):
                    return rowIndex, col
        return None, None
    
    def implies(self, stateChangeOutput, stateChangeEvent, *args):
        currOutput = self.outputForScript(*args)
        return currOutput == stateChangeOutput
    
class TableDoubleClickEvent(TableSelectEvent):
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "MouseDoubleClick"
    
    @classmethod
    def getAssociatedSignatures(cls, widget):
        return [ "CellDoubleClick" ]
    
    def clickCount(self):
        return 2
    
    def _generate(self, cell):
        self.widget.doubleClick(*cell)
    
    def implies(self, stateChangeOutput, stateChangeEvent, *args):
        return isinstance(stateChangeEvent, TableSelectEvent) or SelectEvent.implies(self, stateChangeOutput, stateChangeEvent, *args)
    
    
class TableIndexer(storytext.guishared.TableIndexer):
    def __init__(self, table):
        self.cachedRowCount = 0
        storytext.guishared.TableIndexer.__init__(self, table)
        
    def getRowCount(self):
        return runOnUIThread(self.table.getItemCount)

    def getCellValue(self, row, col):
        return self.table.getItem(row).getText(col)
    
    def getColumnText(self, col):
        return self.table.getColumn(col).getText()
    
    def findColumnIndex(self, columnName):
        return runOnUIThread(storytext.guishared.TableIndexer.findColumnIndex, self, columnName)
    
    def findRowNames(self):
        column, rowNames = runOnUIThread(storytext.guishared.TableIndexer.findRowNames, self)
        self.cachedRowCount = len(rowNames)
        return column, rowNames
    
    def checkNameCache(self):
        if self.getRowCount() != self.cachedRowCount:
            self.primaryKeyColumn, self.rowNames = self.findRowNames()
            self.logger.debug("Rebuilt indexer cache, primary key " + str(self.primaryKeyColumn) +
                              ", row names now " + repr(self.rowNames))
        
    def getCellDescription(self, *args, **kw):
        self.checkNameCache()
        return storytext.guishared.TableIndexer.getCellDescription(self, *args, **kw)

    def getViewCellIndices(self, *args, **kw):
        self.checkNameCache()
        return storytext.guishared.TableIndexer.getViewCellIndices(self, *args, **kw)
    
    
class TableColumnHeaderEvent(SignalEvent):
    def __init__(self, *args):
        SignalEvent.__init__(self, *args)
        self.columnsFound = set()
    
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Selection"
    
    @classmethod
    def getAssociatedSignatures(cls, widget):
        return [ "ColumnSelection" ]
    
    def addColumnListeners(self, *args):
        for column in self.widget.widget.widget.getColumns():
            if column not in self.columnsFound:
                self.columnsFound.add(column)
                column.addListener(*args)

    def addListeners(self, *args):
        self.addColumnListeners(*args)            
        class PaintListener(swt.widgets.Listener):
            def handleEvent(lself, e): #@NoSelf
                storytext.guishared.catchAll(self.addColumnListeners, *args)
        self.widget.widget.widget.addListener(swt.SWT.Paint, PaintListener())
        
    def outputForScript(self, event, *args):
        return " ".join([ self.name, event.widget.getText() ])
    
    def parseArguments(self, argumentString):
        try:
            return self.widget.header(argumentString)
        except swtbot.exceptions.WidgetNotFoundException:
            raise UseCaseScriptError, "Could not find column labelled '" + argumentString + "' in table."
        
    def _generate(self, column):
        column.click()
        

class TreeEvent(SignalEvent):
    def parseArguments(self, argumentString):
        if argumentString:
            item = self.findItem(argumentString, self.widget.getAllItems())
            if item:
                return item
            else:
                raise UseCaseScriptError, "Could not find item labelled '" + argumentString + "' in " + self.getClassDesc() + "."
        else:
            return ""
    
    def getClassDesc(self):
        return self.widget.widget.widget.__class__.__name__.lower()

    def findItem(self, text, items):
        for item in items:
            if self.textMatches(item.getText(), text):
                return item
            if item.isExpanded() and hasattr(item, "getItems"):
                subItem = self.findItem(text, item.getItems())
                if subItem:
                    return subItem
                
    def textMatches(self, text1, text2):
        # Allow custom configuration, e.g. if some name is autogenerated
        return text1 == text2
        
    def getTextToRecord(self, item):
        return DisplayFilter.instance.itemTextCache.pop(item, item.getText())

    def outputForScript(self, event, *args):
        if event.item is not None:
            # Text may have changed since the application listeners have been applied
            text = self.getTextToRecord(event.item)
            return ' '.join([self.name, text])
        else:
            return self.name



class ExpandEvent(TreeEvent):
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Expand"

    def parseArguments(self, argumentString):
        item = TreeEvent.parseArguments(self, argumentString)
        if hasattr(item, "rowCount") and item.rowCount() == 0:
            raise UseCaseScriptError, "Item labelled '" + argumentString + "' in " + self.getClassDesc() + " is not expandable."
        return item
    
    def _generate(self, item):
        item.expand()


class CollapseEvent(TreeEvent):
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Collapse"

    def _generate(self, item):
        item.collapse()


class TreeClickEvent(TreeEvent):
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Selection"
    
    def parseArguments(self, argumentString):
        if argumentString:
            try:
                return [ TreeEvent.parseArguments(self, argumentString) ]
            except UseCaseScriptError:
                return [ TreeEvent.parseArguments(self, part) for part in argumentString.split(",") ]
        else:
            return []

    def shouldRecord(self, event, *args):
        # Seem to get selection events even when nothing has been selected...
        # Record if there is no item, or if we've pressed control (deselecting) or
        # if whatever we selected is still in the selection.
        return TreeEvent.shouldRecord(self, event, *args) and \
            (event.item is None or event.stateMask == swt.SWT.CTRL or event.item in event.widget.getSelection())

    def _generate(self, items):
        if items:
            self.selectItems(items)
        else:
            self.widget.unselect()
            
    def selectItems(self, items):
        # Swtbot select and click methods doesn't seem to generate all events that a mouse click does.
        # In particular the select methods generate events without the item field set which can cause great confusion.
        runOnUIThread(self.widget.widget.widget.setSelection, [ item.widget for item in items ])
        items[0].click()
        for item in items[1:]:
            self.postControlEvent(swt.SWT.KeyDown)
            item.click()
            self.postControlEvent(swt.SWT.KeyUp)
                        
    def postControlEvent(self, eventType):
        event = swt.widgets.Event()
        event.type = eventType
        event.keyCode = swt.SWT.CTRL
        event.character = '\0'
        runOnUIThread(self.widget.display.post, event)
        
    def isStateChange(self):
        return True
    
    def outputForScript(self, event, *args):
        items = event.widget.getSelection()
        if not items:
            return self.name

        args = map(self.getTextToRecord, event.widget.getSelection())
        return ' '.join([self.name, ",".join(args)])
        
    def implies(self, stateChangeOutput, stateChangeEvent, *args):
        currOutput = self.outputForScript(*args)
        return currOutput.startswith(stateChangeOutput)


class TreeDoubleClickEvent(TreeEvent):
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "DefaultSelection"

    def _generate(self, item):
        item.doubleClick()

    def implies(self, stateChangeLine, stateChangeEvent, swtEvent, *args):
        return isinstance(stateChangeEvent, TreeClickEvent) and \
               stateChangeLine == stateChangeEvent.name + " " + swtEvent.item.getText()

class ListClickEvent(StateChangeEvent):
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Selection"
    
    def implies(self, stateChangeOutput, stateChangeEvent, *args):
        currOutput = self.outputForScript(*args)
        return currOutput.startswith(stateChangeOutput)

    def getStateText(self, *args):
        return ",".join(self.widget.selection())

    def _generate(self, indices):
        if len(indices) == 0:
            self.widget.unselect()
        else:
            self.widget.select(indices)
            
    def parseArguments(self, argumentString):
        return self.getIndices(argumentString) if argumentString else []
            
    def shouldRecord(self, *args):
        return not self.widget.widget.widget in CComboSelectEvent.internalWidgets and StateChangeEvent.shouldRecord(self, *args)

    def getIndices(self, argumentString):
        indices = []
        for itemText in argumentString.split(","):
            index = self.widget.indexOf(itemText)
            if index >= 0:
                indices.append(index)
            else:
                raise UseCaseScriptError, "Could not find item labelled '" + itemText + "' in list."
        return indices

class DateTimeEvent(StateChangeEvent):
    def __init__(self, *args, **kw):
        StateChangeEvent.__init__(self, *args, **kw)
        self.dateFormat = self.getDateFormat()

    def getDateFormat(self):
        if runOnUIThread(self.widget.widget.widget.getStyle) & swt.SWT.TIME:
            return util.getDateFormat(swt.SWT.TIME)
        else:
            return util.getDateFormat(swt.SWT.DATE)
    @classmethod
    def getAssociatedSignal(cls, widget):
        return "Selection"
    
    def getStateText(self, *args):
        return self.dateFormat.format(self.widget.getDate())

    def _generate(self, argumentString):
        try:
            currDate = self.dateFormat.parse(argumentString)
            self.widget.setDate(currDate)
        except ParseException:
            raise UseCaseScriptError, "Could not parse date/time argument '" + argumentString + \
                  "', not of format '" + self.dateFormat.toPattern() + "'."

class DisplayFilter:
    instance = None
    def otherEventCount(self, event, isTriggeringEvent):
        relevantEvents = [ e for e in self.eventsFromUser if e is not event and not isTriggeringEvent(e) ]
        return len(relevantEvents)
        
    def getEventFromUser(self, event, isTriggeringEvent):
        if event in self.eventsFromUser:
            return not self.hasPreviousEventOnShell(event, isTriggeringEvent)
        else:
            if len(self.eventsFromUser) == 0:
                self.logger.debug("Rejecting event, it has not yet been seen in the display filter")
            else:
                self.logger.debug("Received event " + event.toString())
                self.logger.debug("Rejecting event, not yet processed " + repr([ e.toString() for e in self.eventsFromUser ]))
            return False
        
    def hasEvents(self):
        return len(self.eventsFromUser) > 0

    def __init__(self, widgetEventTypes):
        self.widgetEventTypes = widgetEventTypes
        self.eventsFromUser = []
        self.delayedAppEvents = []
        self.itemTextCache = {}
        self.logger = logging.getLogger("storytext record")
        DisplayFilter.instance = self
        
    def getShell(self, widget):
        # Note : widget might be an Item rather than a widget!
        if widget is not None and not widget.isDisposed():
            if hasattr(widget, "getShell"):
                return widget.getShell()
            elif hasattr(widget, "getParent"):
                return self.getShell(widget.getParent())

    def hasPreviousEventOnShell(self, event, isTriggeringEvent):
        widget = event.widget
        currShell = self.getShell(widget)
        if not currShell:
            return False

        for e in self.eventsFromUser:
            if e is event:
                return False
            elif not isTriggeringEvent(e) and self.getShell(e.widget) is currShell:
                self.logger.debug("Previous event on shell found: " + repr(e))
                return True
        return False
    
    def hasEventOfType(self, eventTypes, widget):
        return any((event.type in eventTypes and event.widget is widget for event in self.eventsFromUser))
        
    def addFilters(self, display):
        class DisplayListener(swt.widgets.Listener):
            def handleEvent(listenerSelf, e): #@NoSelf
                storytext.guishared.catchAll(self.handleFilterEvent, e)

        for eventType in self.getAllEventTypes():
            self.logger.debug("Adding filter for events of type " + str(eventType))
            runOnUIThread(display.addFilter, eventType, DisplayListener())
            
        self.addApplicationEventFilter(display)

    def handleEventFinished(self, e):        
        # Any application events that were delayed should be no longer, if they haven't been handled yet
        for appEvent in self.delayedAppEvents:
            applicationEventDelay(appEvent, fromLevel=len(self.eventsFromUser), increase=False)
        self.delayedAppEvents = []
        self.logger.debug("Filter removed for event " + e.toString())
        self.eventsFromUser.remove(e)

    def handleFilterEvent(self, e):
        if self.shouldCheckWidget(e.widget, e.type):
            self.logger.debug("Filter for event " + e.toString())
            self.eventsFromUser.append(e)
            class EventFinishedListener(swt.widgets.Listener):
                def handleEvent(listenerSelf, e2): #@NoSelf
                    if e2 is e:
                        storytext.guishared.catchAll(self.handleEventFinished, e)
                    
            runOnUIThread(e.widget.addListener, e.type, EventFinishedListener())
            if e.item and not e.item.isDisposed():
                # Safe guard against the application changing the text before we can record
                self.itemTextCache[e.item] = e.item.getText()
        else:
            self.logger.debug("Filter ignored event " + e.toString())

    def addApplicationEventFilter(self, display):
        class ApplicationEventListener(swt.widgets.Listener):
            def handleEvent(listenerSelf, e): #@NoSelf
                if e.text:
                    storytext.guishared.catchAll(self.registerApplicationEvent, e.text, "system")
        runOnUIThread(display.addFilter, applicationEventType, ApplicationEventListener())
 
    @classmethod       
    def registerApplicationEvent(cls, name, category):
        delayLevel = len(cls.instance.eventsFromUser) if cls.instance else 0
        if delayLevel:
            cls.instance.delayedAppEvents.append(name)
        applicationEvent(name, category, delayLevel=delayLevel)
        
    def shouldCheckWidget(self, widget, eventType):
        if not util.isVisible(widget):
            return False
        for cls, types in self.widgetEventTypes:
            if isinstance(widget, cls) and eventType in types and not self.hasComplexAncestors(widget):
                return True
        return False

    def hasComplexAncestors(self, widget):
        return isinstance(widget.getParent(), swt.widgets.DateTime)

    def getAllEventTypes(self):
        eventTypeSet = set()
        for _, eventTypes in self.widgetEventTypes:
            eventTypeSet.update(eventTypes)
        return eventTypeSet
    
# There is no SWTBot class for these things, so we make our own. We aren't actually going to use it anyway...    
class FakeSWTBotTabFolder(swtbot.widgets.AbstractSWTBot):
    pass

class FakeSWTBotCTabFolder(swtbot.widgets.AbstractSWTBot):
    pass

# There is no way to type text in SWTBotCCombo, so make our own.
class FakeSWTBotCCombo(swtbot.widgets.SWTBotCCombo):
    def typeText(self, text):
        self.setFocus()
        self.keyboard().typeText(text, swtbot.utils.SWTBotPreferences.TYPE_INTERVAL)

class BrowserUpdateMonitor(swt.browser.ProgressListener):
    def __init__(self, widget):
        self.widget = widget
        self.urlOrText = self.getUrlOrText()

    def getUrlOrText(self):
        return util.getRealUrl(self.widget) or self.widget.getText()
    
    def changed(self, e):
        pass
    
    def completed(self, e):
        storytext.guishared.catchAll(self.onCompleted, e)
        
    def onCompleted(self, e):
        newText = self.getUrlOrText()
        if newText != self.urlOrText:
            self.urlOrText = newText
            self.sendApplicationEvent(self.widget.getNameForAppEvent() + " to finish loading", "browser")

    def sendApplicationEvent(self, *args):
        applicationEvent(*args)

class EventPoster:
    def __init__(self, display):
        self.display = display

    def moveMouseAndWait(self, x, y):
        runOnUIThread(storytext.guishared.catchAll, self.postMouseMove, x, y)
        runOnUIThread(storytext.guishared.catchAll, self.waitForCursor, x, y)
       
    def postMouseMove(self, x ,y):
        event = swt.widgets.Event()
        event.type = swt.SWT.MouseMove
        event.x = x
        event.y = y
        self.display.post(event)

    def clickMouse(self):        
        runOnUIThread(storytext.guishared.catchAll, self.postMouseDown)
        runOnUIThread(storytext.guishared.catchAll, self.postMouseUp)

    def postMouseDown(self, button=1):
        event = swt.widgets.Event()
        event.type = swt.SWT.MouseDown
        event.button = button
        self.display.post(event)

    def postMouseUp(self, button=1):
        event = swt.widgets.Event()
        event.type = swt.SWT.MouseUp
        event.button = button
        self.display.post(event)
        
    def checkAndPostKeyPressed(self, keyModifiers):
        if keyModifiers & swt.SWT.CTRL != 0:
            runOnUIThread(storytext.guishared.catchAll, self.postKeyPressed, swt.SWT.CTRL, '\0')
            
    def checkAndPostKeyReleased(self, keyModifiers):
        if keyModifiers & swt.SWT.CTRL != 0:
            runOnUIThread(storytext.guishared.catchAll, self.postKeyReleased, swt.SWT.CTRL, '\0')
            
    def postKeyPressed(self, code, character):
        event = swt.widgets.Event()
        event.type = swt.SWT.KeyDown
        event.keyCode = code
        event.character = character
        self.display.post(event)
        
    def postKeyReleased(self, code, character):
        event = swt.widgets.Event()
        event.type = swt.SWT.KeyUp
        event.keyCode = code
        event.character = character
        self.display.post(event)
   
    def waitForCursor(self, x, y):
        while self.display.getCursorLocation().x != x and self.display.getCursorLocation().y != y:
            time.sleep(0.1)


class WidgetMonitor:
    swtbotMap = { swt.widgets.Button   : (swtbot.widgets.SWTBotButton,
                                         [ (swt.SWT.RADIO, swtbot.widgets.SWTBotRadio),
                                           (swt.SWT.CHECK, swtbot.widgets.SWTBotCheckBox) ]),
                  swt.widgets.MenuItem : (swtbot.widgets.SWTBotMenu, 
                                          [ (swt.SWT.RADIO, SWTBotRadioMenu) ]),
                  swt.widgets.Shell    : (swtbot.widgets.SWTBotShell, []),
                  swt.widgets.ToolItem : ( swtbot.widgets.SWTBotToolbarPushButton,
                                         [ (swt.SWT.DROP_DOWN, swtbot.widgets.SWTBotToolbarDropDownButton),
                                           (swt.SWT.RADIO    , swtbot.widgets.SWTBotToolbarRadioButton),
                                           (swt.SWT.SEPARATOR, swtbot.widgets.SWTBotToolbarSeparatorButton),
                                           (swt.SWT.TOGGLE   , swtbot.widgets.SWTBotToolbarToggleButton) ]),
                  swt.widgets.Spinner  : (swtbot.widgets.SWTBotSpinner, []),
                  swt.widgets.Text     : (swtbot.widgets.SWTBotText, []),
                  swt.widgets.Link     : (swtbot.widgets.SWTBotLink, []),
                  swt.widgets.List     : (swtbot.widgets.SWTBotList, []),
                  swt.widgets.Combo    : (swtbot.widgets.SWTBotCombo, []),
                  swt.custom.CCombo    : (FakeSWTBotCCombo, []),
                  swt.widgets.Table    : (StoryTextSwtBotTable, []),
                  swt.widgets.TableColumn : (swtbot.widgets.SWTBotTableColumn, []),
                  swt.widgets.Tree     : (swtbot.widgets.SWTBotTree, []),
                  swt.widgets.ExpandBar: (swtbot.widgets.SWTBotExpandBar, []),
                  swt.widgets.DateTime : (swtbot.widgets.SWTBotDateTime, []),
                  swt.widgets.TabFolder: (FakeSWTBotTabFolder, []),
                  swt.custom.CTabFolder: (FakeSWTBotCTabFolder, []),
                  swt.browser.Browser  : (swtbot.widgets.SWTBotBrowser, [])
                  }
    def __init__(self, uiMap):
        self.bot = self.createSwtBot()
        self.widgetsMonitored = set()
        self.uiMap = uiMap
        self.uiMap.scriptEngine.eventTypes = eventTypes
        self.displayFilter = self.getDisplayFilterClass()(self.getWidgetEventTypes())
        self.widgetMonitorLock = Lock()

    def handleReplayFailure(self, *args):
        pass # nothing yet, used in derived classes

    def getDisplayFilterClass(self):
        return DisplayFilter

    def createSwtBot(self):
        return swtbot.SWTBot()
        
    def getWidgetEventTypes(self):
        return self.getWidgetEventInfo(lambda eventClass: eventClass.getSignalsToFilter())

    @classmethod
    def getWidgetEventTypeNames(cls):
        return cls.getWidgetEventInfo(lambda eventClass: [ eventClass.getAssociatedSignal(None) ])

    @classmethod
    def getWidgetEventInfo(cls, method):
        allEventTypes = []
        eventTypeDict = dict(eventTypes)
        for widgetClass, (defaultSwtbotClass, styleSwtbotInfo) in cls.swtbotMap.items():
            currEventTypes = set()
            for swtBotClass in [ defaultSwtbotClass] + [ cls for _, cls in styleSwtbotInfo ]:
                for eventClass in eventTypeDict.get(swtBotClass, []):
                    currEventTypes.update(method(eventClass))
            if currEventTypes:
                allEventTypes.append((widgetClass, currEventTypes))
        return allEventTypes
    
    def setUp(self):
        self.forceShellActive()
        self.setUpDisplayFilter()
        allWidgets = self.findAllWidgets()
        self.uiMap.logger.debug("Monitoring all widgets in active shell...")
        self.monitorAllWidgets(list(allWidgets))
        self.uiMap.logger.debug("Done Monitoring all widgets in active shell.")
        
    def forceShellActive(self):
        if os.pathsep == ":": # os.name == "java", so can't find out that way if we're on UNIX
            # Need to do this for running under Xvfb on UNIX
            # Seems to throw exceptions occasionally on Windows, so don't bother
            runOnUIThread(self.bot.getFinder().getShells()[0].forceActive)

    def getDisplay(self):
        return self.bot.getDisplay()

    def setUpDisplayFilter(self):
        display = self.getDisplay()
        self.addMonitorFilter(display)
        self.displayFilter.addFilters(display)

    def addMonitorFilter(self, display):
        class MonitorListener(swt.widgets.Listener):
            def handleEvent(listenerSelf, e): #@NoSelf
                storytext.guishared.catchAll(self.widgetShown, e.widget, e.type)

        monitorListener = MonitorListener()
        runOnUIThread(display.addFilter, swt.SWT.Show, monitorListener)
        runOnUIThread(display.addFilter, swt.SWT.Paint, monitorListener)
        
    def widgetShown(self, parent, eventType):
        if parent not in self.widgetsMonitored:
            self.monitorNewWidgets(parent, eventType == swt.SWT.Show)
            
    def monitorNewWidgets(self, parent, findInvisible=True):
        if findInvisible:
            self.bot.getFinder().setShouldFindInvisibleControls(True)

        widgets = self.findDescendants(parent)
        if findInvisible:
            self.bot.getFinder().setShouldFindInvisibleControls(False)

        self.uiMap.logger.debug("Showing/painting widget of type " +
                                parent.__class__.__name__ + " " + str(id(parent)) + ", monitoring found widgets")
        self.monitorAllWidgets(widgets)
        self.uiMap.logger.debug("Done Monitoring all widgets after showing/painting " + 
                                parent.__class__.__name__ + " " + str(id(parent)) + ".")
        
    def findDescendants(self, widget):
        if isinstance(widget, swt.widgets.Menu):
            return ArrayList(self.getMenuItems(widget))
        else:
            matcher = IsAnything()
            return self.bot.widgets(matcher, widget)

    def getMenuItems(self, menu):
        items = []
        for item in menu.getItems():
            submenu = item.getMenu()
            if submenu:
                items += self.getMenuItems(submenu)
            else:
                items.append(item)
        return items

    def monitorAllWidgets(self, widgets):
        # Called both on the entire initial widget set and whenever a widgets is shown -> different threads
        # Use lock to avoid racing
        widgets += self.getPopupMenus(widgets)
        self.widgetMonitorLock.acquire()
        try:
            newWidgets = [ w for w in widgets if w not in self.widgetsMonitored and not w.isDisposed() ]
            self.widgetsMonitored.update(newWidgets)
        finally:
            self.widgetMonitorLock.release()
        for widget in self.makeAdapters(newWidgets):
            self.uiMap.monitorWidget(widget)
            self.monitorAsynchronousUpdates(widget)

    def monitorAsynchronousUpdates(self, widget):
        # Browsers load their stuff in the background, must wait for them to finish
        if widget.isInstanceOf(swtbot.widgets.SWTBotBrowser):
            monitor = self.getBrowserUpdateMonitorClass()(widget)
            runOnUIThread(widget.widget.widget.addProgressListener, monitor)
            
    def getBrowserUpdateMonitorClass(self):
        return BrowserUpdateMonitor

    def findAllWidgets(self):
        matcher = IsAnything()
        widgets = self.bot.widgets(matcher, runOnUIThread(self.getActiveShell))
        menus = self.bot.getFinder().findMenus(matcher)
        widgets.addAll(menus)
        return widgets

    def getPopupMenus(self, widgets):
        menus = []
        for widget in widgets:
            if isinstance(widget, swt.widgets.Control):
                menuFinder = swtbot.finders.ContextMenuFinder(widget)
                menus += filter(lambda m: m not in self.widgetsMonitored, menuFinder.findMenus(IsAnything()))
        return menus

    def findSwtbotClass(self, widget, widgetClass):
        defaultClass, styleClasses = self.swtbotMap.get(widgetClass)
        for currStyle, styleClass in styleClasses:
            if runOnUIThread(widget.getStyle) & currStyle:
                return styleClass
        return defaultClass

    def makeAdapters(self, widgets):
        adapters = []
        for widget in widgets:
            adapter = self.makeAdapter(widget)
            if adapter:
                adapters.append(adapter)
        return adapters

    def makeAdapter(self, widget):
        for widgetClass in self.swtbotMap.keys():
            if isinstance(widget, widgetClass):
                swtbotClass = self.findSwtbotClass(widget, widgetClass)
                try:
                    return WidgetAdapter.adapt(swtbotClass(widget))
                except RuntimeException:
                    # Sometimes widgets are already disposed
                    pass
        
    def getActiveShell(self):
        finder = self.bot.getFinder()
        activeShell = finder.activeShell()
        if activeShell is not None:
            return activeShell
        shells = filter(lambda s: s.getText(), finder.getShells())
        if shells:
            return shells[-1]
        
    def removeMousePointerIfNeeded(self):
        # If the mouse pointer is inside the window, this might cause accidental mouseovers and indeterminism. Relocate it to 0,0 if so
        display = self.getDisplay()
        def pointerInWindow():
            return self.getActiveShell().getClientArea().contains(display.getCursorLocation())
            
        if runOnUIThread(pointerInWindow):
            self.uiMap.logger.debug("Removing mouse pointer from window, to avoid accidental mouseovers")
            poster = EventPoster(display)
            poster.moveMouseAndWait(0, 0)
            self.uiMap.logger.debug("Mouse pointer now at 0,0")


        
eventTypes =  [ (swtbot.widgets.SWTBotButton            , [ SelectEvent ]),
                (SWTBotRadioMenu                        , [ RadioSelectEvent ]),
                (swtbot.widgets.SWTBotMenu              , [ SelectEvent ]),
                (swtbot.widgets.SWTBotToolbarPushButton , [ SelectEvent ]),
                (swtbot.widgets.SWTBotToolbarDropDownButton , [ SelectEvent ]),
                (swtbot.widgets.SWTBotToolbarRadioButton, [ RadioSelectEvent ]),
                (swtbot.widgets.SWTBotLink              , [ LinkSelectEvent ]),
                (swtbot.widgets.SWTBotRadio             , [ RadioSelectEvent ]),
                (swtbot.widgets.SWTBotSpinner           , [ SpinnerSelectEvent ]),
                (swtbot.widgets.SWTBotText              , [ TextEvent, TextActivateEvent ]),
                (swtbot.widgets.SWTBotShell             , [ ShellCloseEvent, ResizeEvent, FreeTextEvent ]),
                (StoryTextSwtBotTable                   , [ TableColumnHeaderEvent, TableSelectEvent, TableDoubleClickEvent ]),
                (swtbot.widgets.SWTBotTableColumn       , [ TableColumnHeaderEvent ]),
                (swtbot.widgets.SWTBotTree              , [ ExpandEvent, CollapseEvent,
                                                            TreeClickEvent, TreeDoubleClickEvent ]),
                (swtbot.widgets.SWTBotExpandBar         , [ ExpandEvent, CollapseEvent ]),
                (swtbot.widgets.SWTBotList              , [ ListClickEvent ]),
                (swtbot.widgets.SWTBotCombo             , [ ComboTextEvent, TextActivateEvent ]),
                (FakeSWTBotCCombo                       , [ CComboSelectEvent, CComboChangeEvent, TextActivateEvent ]),
                (FakeSWTBotTabFolder                    , [ TabSelectEvent ]),
                (FakeSWTBotCTabFolder                   , [ CTabSelectEvent, CTabCloseEvent ]),
                (swtbot.widgets.SWTBotDateTime          , [ DateTimeEvent ]),
                (swtbot.widgets.SWTBotCheckBox          , [ SelectEvent ]) ]
