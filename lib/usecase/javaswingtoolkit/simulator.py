import usecase.guishared, logging, util
from java.awt import AWTEvent, Toolkit, Component
from java.awt.event import AWTEventListener, MouseAdapter, MouseEvent, KeyEvent, WindowAdapter, \
WindowEvent, ActionEvent, ActionListener, ComponentEvent
from java.lang import Runnable, InterruptedException, System, Runtime
from java.lang.reflect import InvocationTargetException
from javax import swing
import SwingLibrary

swinglib = None

class WidgetAdapter(usecase.guishared.WidgetAdapter):
    def getChildWidgets(self):
        if isinstance(self.widget, swing.JMenu):
            return self.widget.getPopupMenu().getSubElements()
        else:
            return self.widget.getComponents()
        
    def getName(self):
        return self.widget.getName() or ""
    
    def getWidgetTitle(self):
        return ""
            
    def isAutoGenerated(self, name):
        return name == "frame0" or len(name) == 0
    
    def getLabel(self):
        if hasattr(self.widget, "getLabel"):
            return self.widget.getLabel()
        else:
            return ""

#    def getTooltip(self):
#        try:
#            return self.widget.getToolTipText()
#        except:
#            return ""

#    def getFromUIThread(self, method, *args):
#        try:
#            return runOnUIThread(method, *args)
#        except:
#            return ""
    
usecase.guishared.WidgetAdapter.adapterClass = WidgetAdapter

class SignalEvent(usecase.guishared.GuiEvent):
                
    def generate(self, *args):
        self._generate(*args)
            
    def connectRecord(self, method):
        class ClickListener(MouseAdapter):
            def mousePressed(listenerSelf, event):
                listenerSelf.pressedEvent = event
            
            def mouseClicked(listenerSelf, event):
                method(listenerSelf.pressedEvent, self)
              
        util.runOnEventDispatchThread(self.widget.widget.addMouseListener, ClickListener())
        
    def shouldRecord(self, event, *args):
        return Filter.getEventFromUser(event)
    
    def setNameIfNeeded(self):
        mapId = self.widget.getUIMapIdentifier()
        if not mapId.startswith("Name="):
            name = "PyUseCase map ID: " + mapId
            self.widget.setName(name)

class FrameCloseEvent(SignalEvent):
    def _generate(self, *args):
        # What happens here if we don't have a title?
        swinglib.runKeyword("closeWindow", [ self.widget.getTitle() ])
      
    def connectRecord(self, method):
        class WindowCloseListener(WindowAdapter):
            def windowClosing(listenerSelf, event):
                method(event, self)
            
            def windowClosed(listenerSelf, event):
                Filter.stopListening()
                        
        util.runOnEventDispatchThread(self.widget.widget.addWindowListener, WindowCloseListener())
        
    @classmethod
    def getAssociatedSignal(cls, *args):
        return "Close"

class SelectEvent(SignalEvent):
    def _generate(self, *args):
        self.setNameIfNeeded()
        swinglib.runKeyword("clickOnComponent", [ self.widget.getName()])
        
    @classmethod
    def getAssociatedSignal(cls, *args):
        return "Click"

    def shouldRecord(self, event, *args):
        return Filter.getEventFromUser(event) and event.getModifiers() & MouseEvent.BUTTON1_MASK != 0

class StateChangeEvent(SignalEvent):
    def outputForScript(self, *args):
        return ' '.join([self.name, self.getStateText(*args) ])

    def isStateChange(self, *args):
        return True
    
class MenuSelectEvent(SelectEvent):                            
    def connectRecord(self, method):
        class ClickListener(MouseAdapter):
            def mousePressed(listenerSelf, event):
                if not isinstance(event.getSource(), swing.JMenu):
                    listenerSelf.pressedEvent = event
                    
            def mouseReleased(listenerSelf, event):
                if not isinstance(event.getSource(), swing.JMenu):
                    method(listenerSelf.pressedEvent, self)
                    
        util.runOnEventDispatchThread(self.widget.widget.addMouseListener, ClickListener())      
        
    def _generate(self, *args):
        self.setNameIfNeeded()
        path = util.getMenuPathString(self.widget)
        swinglib.runKeyword("selectFromMenu", [ path ])

class TabSelectEvent(SelectEvent):
    def isStateChange(self):
        return True
                    
    def _generate(self, argumentString):
        self.setNameIfNeeded()
        swinglib.runKeyword("selectTab", [ argumentString ])
    
    def outputForScript(self, event, *args):
        swinglib.runKeyword("selectWindow", [ swing.SwingUtilities.getWindowAncestor(self.widget.widget).getTitle()])
        #Should be used when more than oene TabbedPane is used: swinglib.runKeyword("selectTabPane", [ self.widget.getLabel() ])
        text = swinglib.runKeyword("getSelectedTabLabel", [])
        return ' '.join([self.name, text])
     
    def implies(self, *args):
        # State change because it can be implied by TabCloseEvents
        # But don't amalgamate them together, allow several tabs to be selected in sequence
        return False

class TextEvent(StateChangeEvent):
    pass
       
class PushButtonEvent(SelectEvent):
    def _generate(self, *args):
        self.setNameIfNeeded()
        swinglib.runKeyword("pushButton", [ self.widget.getName()])

class ToggleButtonEvent(SelectEvent):
    def _generate(self, *args):
        self.setNameIfNeeded()
        swinglib.runKeyword("pushButton", [ self.widget.getName()]) 
              
class Filter:
    eventsFromUser = []
    logger = None
    eventListener = None
    def __init__(self):
        Filter.logger = logging.getLogger("usecase record")
        
    @classmethod
    def getEventFromUser(cls, event):
        if event in cls.eventsFromUser:
            cls.eventsFromUser.remove(event)
            return True
        else:
            if len(cls.eventsFromUser) == 0:
                cls.logger.debug("Rejecting event, it has not yet been seen in the display filter")
            else:
                cls.logger.debug("Received event " + repr(event))
                cls.logger.debug("Rejecting event, not yet processed " + repr([ repr(e) for e in cls.eventsFromUser ]))
            return False
        
    def getWindow(self, widget):
        return swing.SwingUtilities.getWindowAncestor(widget)
    
    def hasEventOnWindow(self, widget):
        currWindow = self.getWindow(widget)
        if not currWindow:
            return False

        for event in self.eventsFromUser:
            if self.getWindow(event.getSource()) is currWindow:
                return True
        return False
    
    def startListening(self):
        eventMask = AWTEvent.MOUSE_EVENT_MASK | AWTEvent.KEY_EVENT_MASK | AWTEvent.WINDOW_EVENT_MASK | AWTEvent.ACTION_EVENT_MASK
        # Should be commented out if we need to listen to these events:
        #| AWTEvent.WINDOW_EVENT_MASK | AWTEvent.COMPONENT_EVENT_MASK | AWTEvent.ACTION_EVENT_MASK
        #| AWTEvent.ITEM_EVENT_MASK | AWTEvent.INPUT_METHOD_EVENT_MASk
        
        class AllEventListener(AWTEventListener):
            def eventDispatched(listenerSelf, event):
                self.handleEvent(event)
        
        self.eventListener = AllEventListener()
        util.runOnEventDispatchThread(Toolkit.getDefaultToolkit().addAWTEventListener, self.eventListener, eventMask)
    
    @classmethod
    def stopListening(cls):
        util.runOnEventDispatchThread(Toolkit.getDefaultToolkit().removeAWTEventListener, cls.eventListener)
    
    def handleEvent(self, event):
        if isinstance(event.getSource(), Component) and not self.hasEventOnWindow(event.getSource()):
            addToFilter = True;
            if isinstance(event, MouseEvent):
                addToFilter = self.handleMouseEvent(event)
            elif isinstance(event, KeyEvent):
                addToFilter = self.handleKeyEvent(event)
            elif isinstance(event, WindowEvent):
                addToFilter = self.handleWindowEvent(event)
            elif isinstance(event, ActionEvent):
                addToFilter(self.handleActionEvent(event))
            if addToFilter:
                self.logger.debug("Filter for event " + event.toString())    
                self.eventsFromUser.append(event)
            
    def handleMouseEvent(self, event):
        return event.getID() == MouseEvent.MOUSE_PRESSED and not isinstance(event.getSource(), swing.JMenu)
            
    def handleKeyEvent(self, event):
        # TODO: to be implemented
        return False
        
    def handleWindowEvent(self, event):
        return event.getID() == WindowEvent.WINDOW_CLOSING or self.handleComponentEvent(event)
    
    def handleActionEvent(self, event):
        print "Filter handling action event"
        return event.getID() == ActionEvent.ACTION_PERFORMED
    
    def handleComponentEvent(self, event):
        return event.getID() == ComponentEvent.COMPONENT_RESIZED




